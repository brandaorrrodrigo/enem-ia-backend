#!/usr/bin/env python3
"""
=============================================================================
INGEST√ÉO ROBUSTA DE QUEST√ïES REAIS DO ENEM
=============================================================================

Script otimizado para extrair quest√µes REAIS de PDFs oficiais do ENEM.

Melhorias:
- Parser robusto (enem_parser_real.py)
- Validador relaxado (enem_validator_relaxed.py)
- Extra√ß√£o multi-biblioteca (PyPDF2, pdfplumber, pypdf)
- Logs detalhados com motivos de descarte
- Deduplica√ß√£o inteligente
- Metadados autom√°ticos (ano, disciplina)

Uso:
    python ingest_real_questoes.py
    python ingest_real_questoes.py --debug
    python ingest_real_questoes.py --output meu_arquivo.json

Output: real_enem_questoes.json
"""

import os
import json
import hashlib
import re
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional
import logging
import sys

# Import dos novos parsers/validadores
from enem_parser_real import EnemParserReal
from enem_validator_relaxed import EnemValidatorRelaxed

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ============================================================================
# CONFIGURA√á√ÉO
# ============================================================================

PDF_FOLDER = Path(__file__).parent / "pdfs_enem_real"
OUTPUT_FILE = Path(__file__).parent / "real_enem_questoes.json"

# Palavras-chave que indicam que N√ÉO √© caderno de quest√µes
IGNORAR_SE_CONTEM = [
    'gabarito_oficial',
    'respostas',
    'instrucoes',
    'folha_resposta',
    'apostila',
    'resumo',
    'revisao'
]


# ============================================================================
# EXTRA√á√ÉO DE TEXTO DE PDFs
# ============================================================================

def extrair_texto_pdf(pdf_path: Path) -> Optional[str]:
    """
    Extrai texto de um PDF usando m√∫ltiplas bibliotecas

    Ordem de tentativa:
    1. PyPDF2
    2. pdfplumber
    3. pypdf

    Args:
        pdf_path: Caminho do PDF

    Returns:
        Texto extra√≠do ou None se falhar
    """
    # Tentativa 1: PyPDF2
    try:
        import PyPDF2
        texto = []
        with open(pdf_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            for page in pdf_reader.pages:
                texto.append(page.extract_text())

        resultado = '\n'.join(texto)
        if resultado.strip():
            logger.info(f"   ‚úÖ PyPDF2: {len(resultado)} caracteres")
            return resultado
    except ImportError:
        pass
    except Exception as e:
        logger.debug(f"   ‚ö†Ô∏è  PyPDF2 falhou: {e}")

    # Tentativa 2: pdfplumber
    try:
        import pdfplumber
        texto = []
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                page_text = page.extract_text()
                if page_text:
                    texto.append(page_text)

        resultado = '\n'.join(texto)
        if resultado.strip():
            logger.info(f"   ‚úÖ pdfplumber: {len(resultado)} caracteres")
            return resultado
    except ImportError:
        pass
    except Exception as e:
        logger.debug(f"   ‚ö†Ô∏è  pdfplumber falhou: {e}")

    # Tentativa 3: pypdf
    try:
        import pypdf
        texto = []
        with open(pdf_path, 'rb') as file:
            pdf_reader = pypdf.PdfReader(file)
            for page in pdf_reader.pages:
                texto.append(page.extract_text())

        resultado = '\n'.join(texto)
        if resultado.strip():
            logger.info(f"   ‚úÖ pypdf: {len(resultado)} caracteres")
            return resultado
    except ImportError:
        pass
    except Exception as e:
        logger.debug(f"   ‚ö†Ô∏è  pypdf falhou: {e}")

    logger.error(f"   ‚ùå Nenhuma biblioteca de PDF funcionou")
    logger.error(f"   üí° Instale: pip install PyPDF2 pdfplumber")
    return None


# ============================================================================
# PROCESSAMENTO DE PDFs
# ============================================================================

def deve_ignorar_pdf(pdf_name: str) -> bool:
    """
    Verifica se o PDF deve ser ignorado

    Args:
        pdf_name: Nome do arquivo PDF

    Returns:
        True se deve ignorar
    """
    pdf_lower = pdf_name.lower()

    for palavra in IGNORAR_SE_CONTEM:
        if palavra in pdf_lower:
            return True

    return False


def processar_pdf(pdf_path: Path, parser: EnemParserReal, validator: EnemValidatorRelaxed) -> Dict[str, Any]:
    """
    Processa um √∫nico PDF

    Args:
        pdf_path: Caminho do PDF
        parser: Parser de quest√µes
        validator: Validador de quest√µes

    Returns:
        Resultado do processamento
    """
    resultado = {
        'arquivo': pdf_path.name,
        'questoes_parseadas': 0,
        'questoes_validas': 0,
        'questoes_invalidas': 0,
        'questoes': [],
        'motivos_descarte': [],
        'erro': None
    }

    logger.info(f"\nüìÑ Processando: {pdf_path.name}")
    logger.info("-" * 60)

    # Verifica se deve ignorar
    if deve_ignorar_pdf(pdf_path.name):
        logger.info(f"   ‚è≠Ô∏è  IGNORADO: N√£o parece ser caderno de quest√µes")
        resultado['erro'] = 'Ignorado (n√£o √© caderno de quest√µes)'
        return resultado

    # Extrai texto
    logger.info("   üîç Extraindo texto do PDF...")
    texto = extrair_texto_pdf(pdf_path)

    if not texto or len(texto.strip()) < 200:
        logger.warning(f"   ‚ö†Ô∏è  PDF vazio ou texto insuficiente")
        resultado['erro'] = 'Texto vazio ou insuficiente'
        return resultado

    # Extrai metadados do filename
    ano = parser.extrair_ano_do_filename(pdf_path.name)
    disciplina = parser.inferir_disciplina(pdf_path.name, texto)

    metadata = {
        'fonte': pdf_path.name,
        'ano': ano,
        'disciplina': disciplina
    }

    logger.info(f"   üìÖ Ano detectado: {ano or 'N/A'}")
    logger.info(f"   üìö Disciplina inferida: {disciplina or 'N/A'}")

    # Parseia quest√µes
    logger.info("   üìù Parseando quest√µes...")
    try:
        questoes = parser.parse_from_text(texto, metadata)
        resultado['questoes_parseadas'] = len(questoes)
        logger.info(f"   ‚úÖ {len(questoes)} quest√µes parseadas")
    except Exception as e:
        logger.error(f"   ‚ùå Erro no parsing: {e}")
        resultado['erro'] = f'Parsing: {str(e)}'
        return resultado

    if not questoes:
        logger.warning(f"   ‚ö†Ô∏è  Nenhuma quest√£o encontrada no PDF")
        resultado['erro'] = 'Nenhuma quest√£o parseada'
        return resultado

    # Valida quest√µes
    logger.info("   ‚úÖ Validando quest√µes...")
    questoes_validas = []

    for questao in questoes:
        is_valid, erros, avisos = validator.validar_questao(questao)

        if is_valid:
            questoes_validas.append(questao)
        else:
            resultado['questoes_invalidas'] += 1
            # Registra motivo de descarte
            numero = questao.get('numero', '?')
            motivo = ', '.join(erros[:2])  # Primeiros 2 erros
            resultado['motivos_descarte'].append(f"Q{numero}: {motivo}")

    resultado['questoes_validas'] = len(questoes_validas)
    resultado['questoes'] = questoes_validas

    logger.info(f"   ‚úÖ {len(questoes_validas)} quest√µes V√ÅLIDAS")

    if resultado['questoes_invalidas'] > 0:
        logger.info(f"   ‚ùå {resultado['questoes_invalidas']} quest√µes DESCARTADAS")

    return resultado


# ============================================================================
# DEDUPLICA√á√ÉO
# ============================================================================

def criar_hash_questao(questao: Dict) -> str:
    """
    Cria hash √∫nico para detectar duplicatas

    Args:
        questao: Quest√£o

    Returns:
        Hash MD5
    """
    # Usa enunciado + alternativas
    texto = questao.get('enunciado', '').lower().strip()

    alternativas = questao.get('alternativas', {})
    for letra in ['A', 'B', 'C', 'D', 'E']:
        texto += str(alternativas.get(letra, '')).lower().strip()

    return hashlib.md5(texto.encode('utf-8')).hexdigest()


def deduplicate_questoes(todas_questoes: List[Dict]) -> tuple[List[Dict], int]:
    """
    Remove quest√µes duplicadas

    Args:
        todas_questoes: Lista de todas as quest√µes

    Returns:
        (questoes_unicas, num_duplicatas)
    """
    questoes_unicas = []
    hashes_vistos = set()
    duplicatas = 0

    for questao in todas_questoes:
        hash_q = criar_hash_questao(questao)

        if hash_q in hashes_vistos:
            duplicatas += 1
            continue

        hashes_vistos.add(hash_q)
        questoes_unicas.append(questao)

    return questoes_unicas, duplicatas


# ============================================================================
# MAIN
# ============================================================================

def main(debug: bool = False, output_file: Optional[Path] = None):
    """
    Fun√ß√£o principal

    Args:
        debug: Ativa logs debug
        output_file: Arquivo de sa√≠da customizado
    """
    if debug:
        logger.setLevel(logging.DEBUG)

    logger.info("=" * 80)
    logger.info("INGEST√ÉO ROBUSTA DE QUEST√ïES REAIS DO ENEM")
    logger.info("=" * 80)
    logger.info(f"üìÇ Pasta de PDFs: {PDF_FOLDER}")
    logger.info(f"üíæ Arquivo de sa√≠da: {output_file or OUTPUT_FILE}")
    logger.info("=" * 80)

    # Verifica pasta
    if not PDF_FOLDER.exists():
        logger.error(f"\n‚ùå Pasta n√£o encontrada: {PDF_FOLDER}")
        logger.info(f"üí° Criando pasta...")
        PDF_FOLDER.mkdir(parents=True, exist_ok=True)
        logger.info(f"‚úÖ Pasta criada. Coloque os PDFs do ENEM l√° e execute novamente.")
        return 1

    # Busca PDFs
    pdf_files = sorted(PDF_FOLDER.glob("*.pdf"))

    if not pdf_files:
        logger.error(f"\n‚ö†Ô∏è  Nenhum PDF encontrado em: {PDF_FOLDER}")
        logger.info(f"üìå Coloque os PDFs do ENEM (2009-2024) nesta pasta e execute novamente.")
        return 1

    logger.info(f"\nüìö Encontrados {len(pdf_files)} PDFs")

    # Inicializa parser e validator
    parser = EnemParserReal()
    validator = EnemValidatorRelaxed()

    # Estat√≠sticas globais
    stats = {
        'total_pdfs': len(pdf_files),
        'pdfs_processados': 0,
        'pdfs_ignorados': 0,
        'pdfs_com_erro': 0,
        'total_parseadas': 0,
        'total_validas': 0,
        'total_invalidas': 0,
        'total_duplicatas': 0,
        'total_unicas': 0,
        'arquivos_ignorados': [],
        'arquivos_com_erro': [],
        'motivos_descarte': []
    }

    # Processa cada PDF
    todas_questoes = []

    for pdf_path in pdf_files:
        try:
            resultado = processar_pdf(pdf_path, parser, validator)

            if resultado['erro']:
                if 'Ignorado' in resultado['erro']:
                    stats['pdfs_ignorados'] += 1
                    stats['arquivos_ignorados'].append(resultado['arquivo'])
                else:
                    stats['pdfs_com_erro'] += 1
                    stats['arquivos_com_erro'].append({
                        'arquivo': resultado['arquivo'],
                        'erro': resultado['erro']
                    })
            else:
                stats['pdfs_processados'] += 1
                stats['total_parseadas'] += resultado['questoes_parseadas']
                stats['total_validas'] += resultado['questoes_validas']
                stats['total_invalidas'] += resultado['questoes_invalidas']

                # Adiciona quest√µes v√°lidas
                todas_questoes.extend(resultado['questoes'])

                # Registra motivos de descarte
                stats['motivos_descarte'].extend(resultado['motivos_descarte'])

        except Exception as e:
            logger.error(f"   ‚ùå Erro inesperado: {e}")
            stats['pdfs_com_erro'] += 1
            stats['arquivos_com_erro'].append({
                'arquivo': pdf_path.name,
                'erro': f'Erro inesperado: {str(e)}'
            })

    # Deduplica√ß√£o
    logger.info("\n" + "=" * 80)
    logger.info("DEDUPLICA√á√ÉO")
    logger.info("=" * 80)

    questoes_unicas, duplicatas = deduplicate_questoes(todas_questoes)
    stats['total_duplicatas'] = duplicatas
    stats['total_unicas'] = len(questoes_unicas)

    logger.info(f"üìù Total de quest√µes v√°lidas: {len(todas_questoes)}")
    logger.info(f"‚è≠Ô∏è  Duplicatas removidas: {duplicatas}")
    logger.info(f"‚úÖ Quest√µes √∫nicas: {len(questoes_unicas)}")

    # Salva JSON
    logger.info("\n" + "=" * 80)
    logger.info("SALVANDO JSON")
    logger.info("=" * 80)

    output_path = output_file or OUTPUT_FILE

    output_data = {
        'versao': '2.0',
        'tipo': 'questoes_reais_enem',
        'total_questoes': len(questoes_unicas),
        'gerado_em': datetime.now().isoformat(),
        'fonte': 'PDFs oficiais ENEM (2009-2024)',
        'parser': 'enem_parser_real.py',
        'validator': 'enem_validator_relaxed.py',
        'estatisticas': {
            'pdfs_encontrados': stats['total_pdfs'],
            'pdfs_processados': stats['pdfs_processados'],
            'pdfs_ignorados': stats['pdfs_ignorados'],
            'pdfs_com_erro': stats['pdfs_com_erro'],
            'questoes_parseadas': stats['total_parseadas'],
            'questoes_validas': stats['total_validas'],
            'questoes_invalidas': stats['total_invalidas'],
            'duplicatas_removidas': stats['total_duplicatas'],
        },
        'questoes': questoes_unicas
    }

    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(output_data, f, ensure_ascii=False, indent=2)

    logger.info(f"‚úÖ JSON salvo: {output_path}")
    logger.info(f"   üì¶ Tamanho: {output_path.stat().st_size / 1024:.2f} KB")

    # Resumo final
    logger.info("\n" + "=" * 80)
    logger.info("üìä RESUMO FINAL")
    logger.info("=" * 80)
    logger.info(f"üìö PDFs encontrados: {stats['total_pdfs']}")
    logger.info(f"‚úÖ PDFs processados: {stats['pdfs_processados']}")
    logger.info(f"‚è≠Ô∏è  PDFs ignorados: {stats['pdfs_ignorados']}")
    logger.info(f"‚ùå PDFs com erro: {stats['pdfs_com_erro']}")
    logger.info("")
    logger.info(f"üìù Quest√µes parseadas: {stats['total_parseadas']}")
    logger.info(f"‚úÖ Quest√µes v√°lidas: {stats['total_validas']}")
    logger.info(f"‚ùå Quest√µes descartadas: {stats['total_invalidas']}")
    logger.info(f"‚è≠Ô∏è  Duplicatas removidas: {stats['total_duplicatas']}")
    logger.info(f"üéØ QUEST√ïES √öNICAS FINAIS: {stats['total_unicas']}")
    logger.info("")
    logger.info(f"üíæ Arquivo: {output_path}")

    # Detalha arquivos ignorados
    if stats['arquivos_ignorados']:
        logger.info(f"\n‚è≠Ô∏è  Arquivos ignorados ({len(stats['arquivos_ignorados'])}):")
        for arquivo in stats['arquivos_ignorados'][:5]:
            logger.info(f"   ‚Ä¢ {arquivo}")

    # Detalha erros
    if stats['arquivos_com_erro']:
        logger.info(f"\n‚ùå Arquivos com erro ({len(stats['arquivos_com_erro'])}):")
        for info in stats['arquivos_com_erro'][:5]:
            logger.info(f"   ‚Ä¢ {info['arquivo']}: {info['erro']}")

    # Amostra de motivos de descarte
    if stats['motivos_descarte']:
        logger.info(f"\n‚ùå Exemplos de descartes ({len(stats['motivos_descarte'])} total):")
        for motivo in stats['motivos_descarte'][:10]:
            logger.info(f"   ‚Ä¢ {motivo}")

    logger.info("=" * 80)
    logger.info("‚úÖ INGEST√ÉO CONCLU√çDA")
    logger.info("=" * 80)

    return 0


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(
        description='Ingest√£o robusta de quest√µes reais do ENEM',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        '--debug',
        action='store_true',
        help='Ativa logs debug'
    )

    parser.add_argument(
        '--output', '-o',
        type=Path,
        help='Arquivo de sa√≠da customizado'
    )

    args = parser.parse_args()

    sys.exit(main(debug=args.debug, output_file=args.output))
